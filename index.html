<!DOCTYPE html>
<html lang="sv">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Tyraal – index (GM + Player med Export)</title>
<style>
  :root { --bg:#0f1115; --ink:#e6e6e6; --muted:#2a3142; --panel:#141822; --shadow: rgba(0,0,0,.45); --accent:#ffd166; --line:#7dd3fc; }
  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body { margin: 0; background: var(--bg); color: var(--ink); font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; overflow: hidden; }

  /* Stage / world */
  #stage { position: relative; width: 100vw; height: 100vh; overflow: hidden; }
  #world { position: absolute; left: 0; top: 0; transform-origin: 0 0; }
  #map { display:block; user-select: none; -webkit-user-drag: none; pointer-events: none; max-width: none; }

  /* Markers */
  .marker { position: absolute; width: 32px; height: 32px; transform: translate(-50%, -100%); cursor: pointer;
            background-image: url('Ikonkarta.png'); background-size: contain; background-position:center; background-repeat:no-repeat; }
  .marker.open { background-image: url('Ikonkarta2.png'); filter: drop-shadow(0 0 6px var(--accent)); }

  /* Sidebar */
  #sidebar { position: fixed; left: 0; top: 0; height: 100vh; width: 340px; max-width: 90vw; background: rgba(20,24,34,.96);
             border-right: 1px solid var(--muted); box-shadow: 0 6px 20px var(--shadow); z-index: 30; display: none; }
  #sidebar header { display:flex; align-items:center; justify-content: space-between; gap:8px; padding:10px 12px; border-bottom:1px solid #262c3b; }
  #sidebar h3 { margin:0; font-size:16px; font-weight:600; opacity:.9; }
  .mini { border:1px solid var(--muted); background:#1a2030; color:#ddd; padding:6px 10px; border-radius:8px; cursor:pointer; }
  #content { height: calc(100vh - 52px); overflow:auto; padding:12px; }
  #noteBody { background:#0e1220; border:1px solid #2a3142; border-radius:8px; padding:10px; min-height: 180px; white-space: pre-wrap; outline:none; }
  #noteBody:focus { box-shadow: inset 0 0 0 2px #3b82f6; }
  .note-img { max-width: 100%; height: auto; display:block; margin:8px 0; border-radius:6px; border:1px solid #2a3142; cursor: zoom-in; }

  #stage.grabbing, body.grabbing { cursor: grabbing; }

  /* Lightbox */
  #lightbox { position: fixed; inset: 0; background: rgba(0,0,0,.9); display: none; align-items: center; justify-content: center; z-index: 100; }
  #lightbox img { max-width: 96vw; max-height: 96vh; box-shadow: 0 10px 35px rgba(0,0,0,.6); border-radius: 8px; }

  /* Overlay SVG för mätning */
  #overlay { position:absolute; left:0; top:0; overflow:visible; pointer-events:none; }
  .measure-line { stroke: var(--line); stroke-width: 2; fill: none; vector-effect: non-scaling-stroke; }
  .label { font: 12px/1.2 system-ui, sans-serif; fill: #e5e7eb; paint-order: stroke; stroke: #111827; stroke-width: 2; vector-effect: non-scaling-stroke; }

  /* Toolbox */
  #toolbox { position: fixed; right: 12px; top: 12px; display: flex; gap: 8px; z-index: 60; align-items:center; }
  .toolbtn { background:#111827; color:#e5e7eb; border:1px solid #374151; padding:8px 10px; border-radius:10px; cursor:pointer; }
  .toolbtn.active { outline: 2px solid #60a5fa; }
  .pill { background:#0b1220; border:1px solid #2a3142; padding:6px 10px; border-radius:999px; }
  #exportWrap { display:flex; gap:6px; align-items:center; }
  #exportMode { background:#111827; color:#e5e7eb; border:1px solid #374151; padding:6px 8px; border-radius:10px; }

  /* Skallinje (UI-overlay) */
  #scalebar { position: fixed; left: 14px; bottom: 14px; z-index: 70; color:#e5e7eb; font-size: 12px; }
  #scalebar .bar { height: 6px; background: #e5e7eb; border-radius: 3px; box-shadow: 0 1px 0 rgba(0,0,0,.35) inset; }
  #scalebar .label { margin-top: 6px; text-align: center; opacity: .9; }

  /* Player-banner */
  #playerBanner { position: fixed; left: 12px; top: 12px; z-index: 65; background:#0b1220; border:1px solid #2a3142; padding:6px 10px; border-radius:10px; display:none; }
</style>
</head>
<body>
  <aside id="sidebar">
    <header>
      <h3 id="sidebarTitle">Markering</h3>
      <div id="editorBtns">
        <button id="addImg" class="mini" type="button" title="Lägg till bild">+ Bild</button>
        <input id="imgInput" type="file" accept="image/*" style="display:none" />
      </div>
    </header>
    <div id="content">
      <div id="noteBody" contenteditable="true" spellcheck="false">Skriv din not här...</div>
      <p id="pasteHint" style="opacity:.75; font-size:12px; margin-top:8px">Tips: Klistra in (Ctrl/Cmd+V) eller dra‑och‑släpp en bild direkt i textfältet. Klicka på en bild för stor visning.</p>
    </div>
  </aside>

  <div id="toolbox">
    <span class="pill" id="modeLabel">Läge: Notiser</span>
    <button id="btnModeNotes" class="toolbtn active" title="Skapa/hantera notiser">Notiser</button>
    <button id="btnModeMeasure" class="toolbtn" title="Mät avstånd">Mät</button>
    <button id="btnUndo" class="toolbtn" title="Ångra senaste mätpunkt">Ångra</button>
    <button id="btnReset" class="toolbtn" title="Ny mätning">Ny mätning</button>
    <span id="readout" class="pill">Skala: okänd</span>
    <div id="exportWrap" class="pill">
      <label for="exportMode" style="opacity:.8; font-size:12px">Exportläge</label>
      <select id="exportMode">
        <option value="embed">Embed (större data.json)</option>
        <option value="external" selected>External /img (mindre data.json)</option>
      </select>
      <button id="btnExport" class="toolbtn" title="Exportera">Export</button>
    </div>
  </div>

  <div id="playerBanner">Player‑läge (read‑only) – läser data.json</div>

  <div id="scalebar">
    <div class="bar" id="sbBar" style="width:120px"></div>
    <div class="label" id="sbLabel">—</div>
  </div>

  <div id="stage">
    <div id="world">
      <img id="map" src="Tyraal.webp" alt="Tyraal-karta" />
      <svg id="overlay"></svg>
    </div>
  </div>

  <div id="lightbox"><img id="lightboxImg" alt="" /></div>

<script>
(function(){
  const IS_PLAYER = (location.hash === '#player') || (new URLSearchParams(location.search).get('mode') === 'player');

  // Skala
  const METERS_PER_PIXEL = 250000 / 1073.6; // ≈ 232.77 m/px (≈ 4.29 px/km)
  const MAP_WIDTH = 8192, MAP_HEIGHT = 5462;

  let metersPerPixelOverride = NaN;
  const getMetersPerPixel = () => (isNaN(metersPerPixelOverride) ? METERS_PER_PIXEL : metersPerPixelOverride);

  // DOM
  const stage = document.getElementById('stage');
  const world = document.getElementById('world');
  const map = document.getElementById('map');
  const overlay = document.getElementById('overlay');

  const sidebar = document.getElementById('sidebar');
  const sidebarTitle = document.getElementById('sidebarTitle');
  const editorBtns = document.getElementById('editorBtns');
  const noteBody = document.getElementById('noteBody');
  const pasteHint = document.getElementById('pasteHint');
  const addImgBtn = document.getElementById('addImg');
  const imgInput = document.getElementById('imgInput');

  const lightbox = document.getElementById('lightbox');
  const lightboxImg = document.getElementById('lightboxImg');

  const modeLabel = document.getElementById('modeLabel');
  const btnModeNotes = document.getElementById('btnModeNotes');
  const btnModeMeasure = document.getElementById('btnModeMeasure');
  const btnUndo = document.getElementById('btnUndo');
  const btnReset = document.getElementById('btnReset');
  const btnExport = document.getElementById('btnExport');
  const exportModeSel = document.getElementById('exportMode');
  const readout = document.getElementById('readout');

  const sbBar = document.getElementById('sbBar');
  const sbLabel = document.getElementById('sbLabel');
  const playerBanner = document.getElementById('playerBanner');

  // Kamera
  let scale = 1, MIN = 0.1, MAX = 8, startScale = 1;
  let tx = 0, ty = 0, panning = false, sx = 0, sy = 0, stx = 0, sty = 0;
  let imgW = 0, imgH = 0;

  function applyTransform(){
    world.style.transform = `translate(${tx}px, ${ty}px) scale(${scale})`;
    world.querySelectorAll('.marker').forEach(el => { el.style.transform = `translate(-50%, -100%) scale(${1/scale})`; });
    overlay.setAttribute('width', imgW);
    overlay.setAttribute('height', imgH);
    updateScaleBar();
  }
  function clamp(v,a,b){ return Math.min(b, Math.max(a,v)); }
  function getPanBounds(){
    const vw = stage.clientWidth, vh = stage.clientHeight; const w = imgW * scale, h = imgH * scale;
    const minTx = Math.min(0, vw - w), maxTx = 0; const minTy = Math.min(0, vh - h), maxTy = 0; return { minTx, maxTx, minTy, maxTy };
  }
  function clampPan(){ const b = getPanBounds(); tx = clamp(tx, b.minTx, b.maxTx); ty = clamp(ty, b.minTy, b.maxTy); }
  function zoomAt(cx, cy, factor){
    const rect = stage.getBoundingClientRect();
    const x = (cx ?? rect.left + rect.width/2) - rect.left; const y = (cy ?? rect.top + rect.height/2) - rect.top;
    const wx = (x - tx) / scale; const wy = (y - ty) / scale; const ns = clamp(scale * factor, MIN, MAX);
    tx = x - wx * ns; ty = y - wy * ns; scale = ns; clampPan(); applyTransform();
  }
  function fitToScreenAndCenter(){
    const vw = stage.clientWidth, vh = stage.clientHeight; 
    const w0 = map.naturalWidth || MAP_WIDTH; 
    const h0 = map.naturalHeight || MAP_HEIGHT;
    imgW = w0; imgH = h0;
    const s = Math.min(vw / imgW, vh / imgH);
    startScale = s; scale = s; MIN = startScale; const w = imgW * scale, h = imgH * scale; tx = (vw - w)/2; ty = (vh - h)/2; applyTransform();
  }

  stage.addEventListener('wheel', e => { e.preventDefault(); zoomAt(e.clientX, e.clientY, e.deltaY < 0 ? 1.15 : 1/1.15); }, {passive:false});
  stage.addEventListener('mousedown', e => { if (e.button!==0) return; if (mode!== 'notes' || (e.target.classList && e.target.classList.contains('marker'))) return; panning=true; sx=e.clientX; sy=e.clientY; stx=tx; sty=ty; stage.classList.add('grabbing'); document.body.classList.add('grabbing'); });
  window.addEventListener('mousemove', e => { if (panning){ tx = stx + (e.clientX - sx); ty = sty + (e.clientY - sy); clampPan(); applyTransform(); }});
  window.addEventListener('mouseup', () => { panning=false; stage.classList.remove('grabbing'); document.body.classList.remove('grabbing'); });

  // Lagring (notiser)
  const LSK = 'tyraal_markers_meta_v12';
  const DB_NAME = 'tyraal_db'; const DB_STORE = 'notes';
  let db = null;
  function openDB(){ return new Promise((resolve, reject) => { const req = indexedDB.open(DB_NAME, 1); req.onupgradeneeded = () => { db = req.result; if (!db.objectStoreNames.contains(DB_STORE)) db.createObjectStore(DB_STORE, { keyPath: 'id' }); }; req.onsuccess = () => { db = req.result; resolve(db); }; req.onerror = () => reject(req.error); }); }
  function idbGet(id){ return new Promise((resolve, reject) => { const tx = db.transaction(DB_STORE, 'readonly'); const st = tx.objectStore(DB_STORE); const r = st.get(id); r.onsuccess = () => resolve(r.result?.html || ''); r.onerror = () => reject(r.error); }); }
  function idbSet(id, html){ return new Promise((resolve, reject) => { const tx = db.transaction(DB_STORE, 'readwrite'); const st = tx.objectStore(DB_STORE); const r = st.put({ id, html }); r.onsuccess = () => resolve(); r.onerror = () => reject(r.error); }); }
  function idbBulkGet(ids){ return Promise.all(ids.map(id => idbGet(id).then(html => ({ id, html })))); }
  function saveMeta(){ if (IS_PLAYER) return; const out = [...world.querySelectorAll('.marker')].map(m => ({ id: m.dataset.id, x: parseFloat(m.style.left), y: parseFloat(m.style.top) })); try { localStorage.setItem(LSK, JSON.stringify(out)); } catch(e){} }
  async function saveHTML(id, html){ if (IS_PLAYER) return; try { await idbSet(id, html); } catch(e){} }
  async function loadAllFromLocal(){ const meta = JSON.parse(localStorage.getItem(LSK) || '[]'); meta.forEach(o => createMarker(o.x, o.y, o.id, false)); const htmls = await idbBulkGet(meta.map(m => m.id)); htmls.forEach(({id, html}) => { store[id] = { html: html || '' }; }); }

  // Player: läs från data.json
  async function loadAllFromJSON(){
    try {
      const res = await fetch('data.json', { cache: 'no-store' });
      if (!res.ok) throw new Error('Kunde inte läsa data.json');
      const data = await res.json();
      if (typeof data.metersPerPixel === 'number' && isFinite(data.metersPerPixel)) metersPerPixelOverride = data.metersPerPixel;
      if (Array.isArray(data.markers)){
        data.markers.forEach(m => { createMarker(m.x, m.y, m.id, false); store[m.id] = { html: m.html || '' }; });
      }
    } catch (err){ console.error(err); alert('Kunde inte ladda spelardata (data.json).'); }
  }

  // Per‑markör cache
  const store = {}; let openId = null;

  // ===== ASSETS (för export & preview) =====
  const assets = new Map(); // filename -> Blob

  function mimeToExt(mime){ if (!mime) return 'bin'; if (mime.includes('png')) return 'png'; if (mime.includes('jpeg')||mime.includes('jpg')) return 'jpg'; if (mime.includes('webp')) return 'webp'; if (mime.includes('gif')) return 'gif'; return 'bin'; }
  function sanitizeName(str){ return (str || 'asset').toLowerCase().replace(/[^a-z0-9._-]+/g,'-').replace(/^-+|-+$/g,''); }
  async function hashArrayBuffer(buf){ const h = await crypto.subtle.digest('SHA-1', buf); const b = new Uint8Array(h); return Array.from(b).map(x=>x.toString(16).padStart(2,'0')).join('').slice(0,12); }
  function dataURLToBlob(dataUrl){ const [head, body] = dataUrl.split(','); const mimeMatch = head.match(/data:(.*?);/); const mime = (mimeMatch && mimeMatch[1]) || 'application/octet-stream'; const bin = atob(body); const len = bin.length; const arr = new Uint8Array(len); for (let i=0;i<len;i++) arr[i] = bin.charCodeAt(i); return new Blob([arr], { type: mime }); }
  const objectURLForPreview = blob => URL.createObjectURL(blob);

  // === Persistens-helpers: spara alltid "img/<filnamn>" i lagrad HTML ===
  function serializeNoteHTMLForStorage(root){
    const clone = root.cloneNode(true);
    clone.querySelectorAll('img').forEach(img => {
      const fname = img.getAttribute('data-filename');
      const persist = img.getAttribute('data-src-persist');
      if (fname){ img.setAttribute('data-filename', fname); }
      img.removeAttribute('srcset');
      if (persist){ img.setAttribute('src', persist); }
      else if (fname){ img.setAttribute('src', `img/${fname}`); }
    });
    return clone.innerHTML;
  }
  function normalizeLoadedNoteHTML(html){
    const wrap = document.createElement('div'); wrap.innerHTML = html || '';
    wrap.querySelectorAll('img').forEach(img => {
      const fname = img.getAttribute('data-filename');
      const src = img.getAttribute('src') || '';
      if (fname && (src.startsWith('blob:') || src.startsWith('data:'))){ img.setAttribute('src', `img/${fname}`); }
    });
    return wrap.innerHTML;
  }

  // Bildinmatning
  let inserting = false, handlersBound = false, fileDialogOpen = false, lastOpenPromptTs = 0;

  async function insertImagesFromFiles(files){
    if (inserting) return; inserting = true;
    try {
      for (const f of files){
        if (!f || !f.type || !f.type.startsWith('image/')) continue;
        const ext = mimeToExt(f.type);
        const nameBase = sanitizeName(f.name?.split('.')[0]) || 'note';
        const buf = await f.arrayBuffer();
        const h = await hashArrayBuffer(buf);
        const filename = `${nameBase}-${h}.${ext}`;
        const blob = new Blob([buf], { type: f.type });
        assets.set(filename, blob);

        const img = document.createElement('img');
        img.className = 'note-img';
        img.dataset.filename = filename; // persistent id
        img.setAttribute('data-src-persist', `img/${filename}`);
        // snabbrendering lokalt
        img.src = objectURLForPreview(blob);
        attachImageClick(img);
        noteBody.appendChild(img);
      }
      if (openId){ const html = serializeNoteHTMLForStorage(noteBody); store[openId] = { html }; await saveHTML(openId, html); saveMeta(); }
    } finally { inserting = false; }
  }

  function attachImageClick(img){ img.addEventListener('click', e => { e.stopPropagation(); openLightbox(img.src); }); }

  function bindOnce(){ if (handlersBound) return; handlersBound = true; if (!IS_PLAYER){
      addImgBtn.addEventListener('pointerdown', e => { e.preventDefault(); e.stopPropagation(); const now = Date.now(); if (fileDialogOpen || now - lastOpenPromptTs < 600) return; fileDialogOpen = true; lastOpenPromptTs = now; imgInput.value=''; imgInput.click(); }, {passive:false});
      imgInput.addEventListener('change', async e => { e.preventDefault(); e.stopPropagation(); try{ const files=e.target.files; if (files && files.length) await insertImagesFromFiles(files);} finally{ imgInput.value=''; fileDialogOpen=false; } });
      noteBody.addEventListener('paste', async e => { const items = e.clipboardData?.items || []; const files = []; for (const it of items){ if (it.kind==='file' && it.type.startsWith('image/')) files.push(it.getAsFile()); } if (files.length){ e.preventDefault(); e.stopPropagation(); if (!inserting) await insertImagesFromFiles(files); } });
      noteBody.addEventListener('dragover', e => { e.preventDefault(); e.stopPropagation(); });
      noteBody.addEventListener('drop', async e => { e.preventDefault(); e.stopPropagation(); if (e.dataTransfer?.files?.length && !inserting) await insertImagesFromFiles(e.dataTransfer.files); });
      noteBody.addEventListener('input', async () => { if(openId){ const html = serializeNoteHTMLForStorage(noteBody); store[openId] = { html }; await saveHTML(openId, html); saveMeta(); }});
    } }

  // Lightbox
  function openLightbox(src){ lightboxImg.src = src; lightbox.style.display = 'flex'; }
  function closeLightbox(){ lightbox.style.display = 'none'; lightboxImg.src = ''; }
  lightbox.addEventListener('click', closeLightbox);

  // Markörer
  let creating = false, lastCreateTs = 0, lastCreatePos = { x: NaN, y: NaN };
  function tooClose(a,b){ if (!isFinite(a.x)||!isFinite(a.y)||!isFinite(b.x)||!isFinite(b.y)) return false; const dx=a.x-b.x, dy=a.y-b.y; return (dx*dx+dy*dy) < 100; }
  function uid(){ return Math.random().toString(36).slice(2,9); }
  function clientToWorld(e){ const rect = stage.getBoundingClientRect(); const cx = e.clientX - rect.left; const cy = e.clientY - rect.top; return { wx: (cx - tx) / scale, wy: (cy - ty) / scale }; }

  stage.addEventListener('dblclick', e => {
    if (mode !== 'notes') return; if (IS_PLAYER) return;
    if (e.target.classList && (e.target.classList.contains('marker') || e.target.closest('#sidebar'))) return;
    e.preventDefault(); e.stopPropagation();
    const now = Date.now(); if (creating || now - lastCreateTs < 350) return;
    const rect = stage.getBoundingClientRect(); const cx = e.clientX - rect.left; const cy = e.clientY - rect.top; const wx = (cx - tx) / scale; const wy = (cy - ty) / scale; if (!isFinite(wx) || !isFinite(wy)) return;
    const pos = { x: wx, y: wy }; if (tooClose(pos, lastCreatePos) && now - lastCreateTs < 1000) return;
    creating = true; lastCreateTs = now; lastCreatePos = pos;
    const id = uid(); store[id] = { html: 'Skriv din not här...' };
    createMarker(wx, wy, id, true); openMarker(id);
    setTimeout(() => { creating = false; }, 200);
  }, { passive:false });

  function createMarker(wx, wy, id, saveNow=true){
    if (!isFinite(wx) || !isFinite(wy)) return null;
    const m = document.createElement('div'); m.className = 'marker'; m.dataset.id = id; m.style.left = wx + 'px'; m.style.top = wy + 'px';
    m.addEventListener('click', ev => { ev.stopPropagation(); if (openId === id) { closeSidebar(); } else { openMarker(id); } });
    m.addEventListener('contextmenu', async ev => { if (IS_PLAYER) return; ev.preventDefault(); if (confirm('Ta bort denna markering och dess notis?')) { if (openId === id) closeSidebar(); world.removeChild(m); delete store[id]; saveMeta(); try { await idbSet(id, ''); } catch(_){} } });
    // Drag (GM)
    let draggingLocal = false; let dx = 0, dy = 0;
    m.addEventListener('mousedown', ev => { if (mode !== 'notes') return; if (IS_PLAYER) return; if (ev.button!==0) return; draggingLocal = true; const p=clientToWorld(ev); dx = p.wx - parseFloat(m.style.left); dy = p.wy - parseFloat(m.style.top); document.body.classList.add('grabbing'); stage.classList.add('grabbing'); ev.preventDefault(); });
    window.addEventListener('mousemove', ev => { if (!draggingLocal) return; const p=clientToWorld(ev); m.style.left = (p.wx - dx) + 'px'; m.style.top = (p.wy - dy) + 'px'; });
    window.addEventListener('mouseup', () => { if (draggingLocal){ draggingLocal=false; document.body.classList.remove('grabbing'); stage.classList.remove('grabbing'); saveMeta(); } });

    world.appendChild(m);
    if (saveNow) saveMeta();
    return m;
  }

  async function openMarker(id){
    if (openId && openId !== id){ const prev = world.querySelector(`.marker[data-id="${openId}"]`); if (prev) prev.classList.remove('open'); }
    openId = id; const marker = world.querySelector(`.marker[data-id="${id}"]`); if (marker) marker.classList.add('open');
    if (!store[id] || typeof store[id].html !== 'string'){ const html = await idbGet(id); store[id] = { html: html || 'Skriv din not här...' }; }

    const normalized = normalizeLoadedNoteHTML(store[id].html || 'Skriv din not här...');
    noteBody.innerHTML = normalized;

    // Rebind previews: om vi har blobbar i minnet, visa dem; annars ladda från img/<filnamn>
    noteBody.querySelectorAll('img').forEach(img => {
      attachImageClick(img);
      const fname = img.getAttribute('data-filename');
      if (fname){ img.setAttribute('data-src-persist', `img/${fname}`); }
      if (fname && assets.has(fname)){
        img.src = objectURLForPreview(assets.get(fname));
      }
    });

    sidebarTitle.textContent = 'Markering ' + id; sidebar.style.display = 'block';
    bindOnce();
    noteBody.contentEditable = IS_PLAYER ? 'false' : 'true';
    editorBtns.style.display = IS_PLAYER ? 'none' : 'flex';
    pasteHint.style.display = IS_PLAYER ? 'none' : 'block';
  }
  function closeSidebar(){ sidebar.style.display = 'none'; if (openId){ const marker = world.querySelector(`.marker[data-id="${openId}"]`); if (marker) marker.classList.remove('open'); } openId = null; }
  stage.addEventListener('click', e => { if (mode !== 'notes') return; if (creating) return; if (e.target.classList && e.target.classList.contains('marker')) return; closeSidebar(); });

  // Mätning
  let mode = 'notes';
  let measurePoints = []; let measurePath = null;

  function setMode(newMode){
    mode = newMode;
    btnModeNotes.classList.toggle('active', mode==='notes');
    btnModeMeasure.classList.toggle('active', mode==='measure');
    modeLabel.textContent = 'Läge: ' + (mode==='notes' ? 'Notiser' : 'Mätning');
    if (mode==='measure') closeSidebar();
  }
  btnModeNotes.addEventListener('click', () => setMode('notes'));
  btnModeMeasure.addEventListener('click', () => setMode('measure'));
  btnUndo.addEventListener('click', () => { if (mode !== 'measure') setMode('measure'); measurePoints.pop(); updateMeasurePath(); });
  btnReset.addEventListener('click', () => { if (mode !== 'measure') setMode('measure'); measurePoints = []; updateMeasurePath(); });

  function formatMeters(m){ return (m < 1000) ? Math.round(m) + ' m' : (m/1000).toFixed(2) + ' km'; }
  function updateReadout(){ const pxPerKm = 1000 / getMetersPerPixel(); readout.textContent = 'Skala: ' + Math.round(pxPerKm) + ' px/km'; }
  updateReadout();

  function updateMeasurePath(){
    if (!measurePoints.length) { if (measurePath) { measurePath.remove(); measurePath=null; } updateReadout(); return; }
    const d = measurePoints.map((p,i)=> (i? 'L':'M') + p.x + ' ' + p.y).join(' ');
    if (!measurePath){ measurePath = document.createElementNS('http://www.w3.org/2000/svg','path'); measurePath.setAttribute('class','measure-line'); overlay.appendChild(measurePath); }
    measurePath.setAttribute('d', d);

    let totalPx = 0; for (let i=1;i<measurePoints.length;i++){ const a=measurePoints[i-1], b=measurePoints[i]; totalPx += Math.hypot(b.x-a.x, b.y-a.y); }
    readout.textContent = 'Total: ' + formatMeters(totalPx * getMetersPerPixel());
  }

  stage.addEventListener('click', e => { if (mode!=='measure') return; const rect = stage.getBoundingClientRect(); const wx = (e.clientX - rect.left - tx) / scale; const wy = (e.clientY - rect.top - ty) / scale; measurePoints.push({x:wx,y:wy}); updateMeasurePath(); });
  window.addEventListener('keydown', e => { if (mode!=='measure') return; if (e.key==='Escape'){ measurePoints=[]; updateMeasurePath(); } if (e.key==='Backspace' || e.key==='Delete'){ measurePoints.pop(); updateMeasurePath(); } });

  // Skallinje
  const SCALE_CANDIDATES = [500, 1000, 2000, 5000, 10000, 20000, 50000, 100000, 200000];
  function updateScaleBar(){
    const targetMin = 80, targetMax = 220;
    let best = SCALE_CANDIDATES[0];
    let bestPx = metersToScreenPx(best);
    for (const m of SCALE_CANDIDATES){
      const px = metersToScreenPx(m);
      if (px >= targetMin && px <= targetMax){ best = m; bestPx = px; break; }
      if (Math.abs(px - targetMin) < Math.abs(bestPx - targetMin)){ best = m; bestPx = px; }
    }
    sbBar.style.width = Math.max(10, Math.round(bestPx)) + 'px';
    sbLabel.textContent = (best < 1000) ? (best + ' m') : ((best/1000) + ' km');
  }
  const metersToScreenPx = m => (m / getMetersPerPixel()) * scale;

  // Export
  function downloadBlob(blob, filename){ const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = filename; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(a.href); }

  async function exportData(){
    try {
      await openDB();
      const meta = JSON.parse(localStorage.getItem(LSK) || '[]');
      const htmls = await idbBulkGet(meta.map(m => m.id));
      const htmlById = {}; htmls.forEach(({id, html}) => { htmlById[id] = html || ''; });
      const mode = (exportModeSel?.value) || 'embed';
      const markers = meta.map(m => ({ id: m.id, x: m.x, y: m.y, html: htmlById[m.id] || '' }));

      if (mode === 'external'){
        const assetFiles = new Map();
        for (const mk of markers){
          const wrap = document.createElement('div'); wrap.innerHTML = mk.html;
          wrap.querySelectorAll('img').forEach(img => {
            const fname = img.getAttribute('data-filename');
            if (fname && assets.has(fname)){
              img.setAttribute('src', `img/${fname}`);
              assetFiles.set(fname, assets.get(fname));
            } else {
              const src = img.getAttribute('src') || '';
              if (src.startsWith('data:')){
                const blob = dataURLToBlob(src); const ext = mimeToExt(blob.type);
                const gen = `note-${Date.now()}-${Math.random().toString(36).slice(2,8)}.${ext}`;
                assetFiles.set(gen, blob); img.setAttribute('src', `img/${gen}`);
              }
            }
          });
          mk.html = wrap.innerHTML;
        }
        const payload = { exportedAt: new Date().toISOString(), metersPerPixel: getMetersPerPixel(), markers };
        downloadBlob(new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' }), 'data.json');
        for (const [name, blob] of assetFiles){ downloadBlob(blob, `img/${name}`); }
        const manifest = JSON.stringify({ files: [...assetFiles.keys()] }, null, 2);
        downloadBlob(new Blob([manifest], {type:'application/json'}), 'img/manifest.json');
        return;
      }

      // Embed
      const payload = { exportedAt: new Date().toISOString(), metersPerPixel: getMetersPerPixel(), markers };
      downloadBlob(new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' }), 'data.json');
    } catch(err){ console.error(err); alert('Export misslyckades: ' + err.message); }
  }
  btnExport.addEventListener('click', () => { if (IS_PLAYER) return; exportData(); });

  // Init
  async function init(){
    await openDB();
    if (IS_PLAYER){
      playerBanner.style.display = 'block';
      document.getElementById('exportWrap').style.display = 'none';
      await loadAllFromJSON();
      pasteHint.style.display = 'none'; editorBtns.style.display = 'none';
    } else {
      await loadAllFromLocal();
    }
    fitToScreenAndCenter(); clampPan(); applyTransform(); bindOnce(); updateReadout();
  }
  if (map.complete && map.naturalWidth) init(); else map.onload = init;
  window.addEventListener('resize', () => { clampPan(); applyTransform(); });
})();
</script>
</body>
</html>
